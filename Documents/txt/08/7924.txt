By the late 1960s, data storage devices and computer terminals became inexpensive enough that programs could be created by typing directly into the computers.
 Auxiliary tasks accompanying and related to programming include analyzing requirements, testing, debugging (investigating and fixing problems), implementation of build systems, and management of derived artifacts, such as programs' machine code.
Many programmers use forms of Agile software development where the various stages of formal software development are more integrated together into short cycles that take a few weeks rather than years.
In 1801, the Jacquard loom could produce entirely different weaves by changing the "program" â€“ a series of pasteboard cards with holes punched in them.
Methods of measuring programming language popularity include: counting the number of job advertisements that mention the language, the number of books sold and courses teaching the language (this overestimates the importance of newer languages), and estimates of the number of existing lines of code written in the language (this underestimates the number of users of business languages such as COBOL).
 High-level languages made the process of developing a program simpler and more understandable, and less bound to the underlying hardware.
 It is very difficult to determine what are the most popular modern programming languages.
It affects the aspects of quality above, including portability, usability and most importantly maintainability.
This can be a non-trivial task, for example as with parallel processes or some unusual software bugs.
Ideally, the programming language best suited for the task at hand will be selected.
 The first step in most formal software development processes is requirements analysis, followed by testing to determine value modeling, implementation, and failure elimination (debugging).
 Code-breaking algorithms have also existed for centuries.
Sometimes software development is known as software engineering, especially when it employs formal methods or follows an engineering design process.
 These compiled languages allow the programmer to write programs in terms that are syntactically richer, and more capable of abstracting the code, making it easy to target varying machine instruction sets via compilation declarations and heuristics.
There are many approaches to the Software development process.