 Various visual programming languages have also been developed with the intent to resolve readability concerns by adopting non-traditional approaches to code structure and display.
Many applications use a mix of several languages in their construction and use.
 Auxiliary tasks accompanying and related to programming include analyzing requirements, testing, debugging (investigating and fixing problems), implementation of build systems, and management of derived artifacts, such as programs' machine code.
By the late 1960s, data storage devices and computer terminals became inexpensive enough that programs could be created by typing directly into the computers.
A study found that a few simple readability transformations made code shorter and drastically reduced the time to understand it.
 Debugging is a very important task in the software development process since having defects in a program can have significant consequences for its users.
They are the building blocks for all software, from the simplest applications to the most sophisticated ones.
As early as the 9th century, a programmable music sequencer was invented by the Persian Banu Musa brothers, who described an automated mechanical flute player in the Book of Ingenious Devices.
However, Charles Babbage had already written his first program for the Analytical Engine in 1837.
Use of a static code analysis tool can help detect some possible problems.
Proficient programming usually requires expertise in several different subjects, including knowledge of the application domain, details of programming languages and generic code libraries, specialized algorithms, and formal logic.
It is usually easier to code in "high-level" languages than in "low-level" ones.
It affects the aspects of quality above, including portability, usability and most importantly maintainability.
Text editors were also developed that allowed changes and corrections to be made much more easily than with punched cards.
When debugging the problem in a GUI, the programmer can try to skip some user interaction from the original problem description and check if remaining actions are sufficient for bugs to appear.