It is usually easier to code in "high-level" languages than in "low-level" ones.
Assembly languages were soon developed that let the programmer specify instruction in a text format (e.g., ADD X, TOTAL), with abbreviations for each operation code and meaningful names for specifying addresses.
 Various visual programming languages have also been developed with the intent to resolve readability concerns by adopting non-traditional approaches to code structure and display.
Ideally, the programming language best suited for the task at hand will be selected.
It affects the aspects of quality above, including portability, usability and most importantly maintainability.
It involves designing and implementing algorithms, step-by-step specifications of procedures, by writing code in one or more programming languages.
 In the 1880s, Herman Hollerith invented the concept of storing data in machine-readable form.
Unreadable code often leads to bugs, inefficiencies, and duplicated code.

 The first computer program is generally dated to 1843, when mathematician Ada Lovelace published an algorithm to calculate a sequence of Bernoulli numbers, intended to be carried out by Charles Babbage's Analytical Engine.
Later a control panel (plug board) added to his 1906 Type I Tabulator allowed it to be programmed for different jobs, and by the late 1940s, unit record equipment such as the IBM 602 and IBM 604, were programmed by control panels in a similar way, as were the first electronic computers.
Trade-offs from this ideal involve finding enough programmers who know the language to build a team, the availability of compilers for that language, and the efficiency with which programs written in a given language execute.
For example, when a bug in a compiler can make it crash when parsing some large source file, a simplification of the test case that results in only few lines from the original source file can be sufficient to reproduce the same crash.
 These compiled languages allow the programmer to write programs in terms that are syntactically richer, and more capable of abstracting the code, making it easy to target varying machine instruction sets via compilation declarations and heuristics.
 Machine code was the language of early programs, written in the instruction set of the particular machine, often in binary notation.