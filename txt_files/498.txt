Many applications use a mix of several languages in their construction and use.
Trade-offs from this ideal involve finding enough programmers who know the language to build a team, the availability of compilers for that language, and the efficiency with which programs written in a given language execute.
Integrated development environments (IDEs) aim to integrate all such help.
Trial-and-error/divide-and-conquer is needed: the programmer will try to remove some parts of the original test case and check if the problem still exists.
The purpose of programming is to find a sequence of instructions that will automate the performance of a task (which can be as complex as an operating system) on a computer, often for solving a given problem.
Some languages are more prone to some kinds of faults because their specification does not require compilers to perform as much checking as other languages.
It affects the aspects of quality above, including portability, usability and most importantly maintainability.
When debugging the problem in a GUI, the programmer can try to skip some user interaction from the original problem description and check if remaining actions are sufficient for bugs to appear.
The source code of a program is written in one or more languages that are intelligible to programmers, rather than machine code, which is directly executed by the central processing unit.
Ideally, the programming language best suited for the task at hand will be selected.
A study found that a few simple readability transformations made code shorter and drastically reduced the time to understand it.
Provided the functions in a library follow the appropriate run-time conventions (e.g., method of passing arguments), then these functions may be written in any other language.
Compiling takes the source code from a low-level programming language and converts it into machine code.
Ideally, the programming language best suited for the task at hand will be selected.
 These compiled languages allow the programmer to write programs in terms that are syntactically richer, and more capable of abstracting the code, making it easy to target varying machine instruction sets via compilation declarations and heuristics.